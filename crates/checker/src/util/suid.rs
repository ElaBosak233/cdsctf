//! Suid util for suid module.
//!
//! # What is `suid`
//! A fake uuid with steganography.
//!
//! Modified from https://github.com/ret2shell/ret2script.

use std::io;

use aes::cipher::{BlockDecrypt, BlockEncrypt, KeyInit};
use anyhow::anyhow;
use ring::rand::{SecureRandom, SystemRandom};
use uuid::Uuid;

pub fn generate_aes_pair(str: &str) -> ([u8; 16], [u8; 16]) {
    let hash = ring::digest::digest(&ring::digest::SHA256, str.as_bytes());
    let key = hash.as_ref()[0..16].try_into().unwrap();
    let iv = hash.as_ref()[16..32].try_into().unwrap();
    (key, iv)
}

/// Encode seed to suid with data and key.
///
/// # Params
/// - `seed`: The origin flag. Such as `HelloWorld`.
/// - `data`: The data which is used to hide into leet flag. Usually operator's
///   id.
/// - `key`: The key for encryption.
pub fn encode(seed: &str, data: i64, key: &str, hyphenated: bool) -> String {
    let (aes_key, _) = generate_aes_pair(&key);
    // dump template into 16 bytes hash
    let digest = ring::digest::digest(&ring::digest::SHA256, seed.as_bytes());
    let mut hash_slice = [0u8; 16];
    hash_slice.copy_from_slice(&digest.as_ref()[2..18]);

    // xor
    let encrypted = crate::util::xxtea::encrypt_raw(&data.to_le_bytes(), key);
    // turn the encrypted data into an i64
    let mut encrypted_slice = [0u8; 8];
    encrypted_slice.copy_from_slice(&encrypted);
    // generate random bytes (salt)
    let rng = SystemRandom::new();
    let mut rand_bytes = [0u8; 4];
    rng.fill(&mut rand_bytes).unwrap();
    for i in 0..8 {
        if i % 2 == 0 {
            // we will reserve 4 bytes in order to check whether the
            // flag is broken
            hash_slice[i * 2] ^= rand_bytes[i / 2];
        }
        hash_slice[i * 2 + 1] ^= encrypted_slice[i];
    }
    // println!("hash: {:?}", hash_slice);

    // aes ecb
    let cipher = aes::Aes128::new_from_slice(&aes_key).unwrap();
    let mut block = aes::Block::default();
    block.copy_from_slice(&hash_slice);
    cipher.encrypt_block(&mut block);

    let mut result = String::new();
    for i in 0..16 {
        result.push_str(&format!("{:02x}", block[i]));
        if hyphenated && (i == 3 || i == 5 || i == 7 || i == 9) {
            result.push('-');
        }
    }
    // println!("result: {:?}", result);
    result
}

/// Decode payload to data with seed and key.
///
/// # Params
/// - `seed`: The origin flag. Such as `HelloWorld`.
/// - `payload`: The suid flag which is generated by the `encode` function.
/// - `key`: The key for encryption.
pub fn decode(seed: &str, payload: &str, key: &str) -> Result<i64, anyhow::Error> {
    let input_data = Uuid::parse_str(payload)?.as_simple().to_string();
    let data_slice =
        hex::decode(input_data).map_err(|_| io::Error::other("suid format mismatch"))?;

    let (aes_key, _) = generate_aes_pair(key);
    let cipher = aes::Aes128::new_from_slice(&aes_key).unwrap();
    let mut block = aes::Block::default();
    block.copy_from_slice(&data_slice);
    cipher.decrypt_block(&mut block);

    // dump template into 16 bytes hash
    let digest = ring::digest::digest(&ring::digest::SHA256, seed.as_bytes());
    let mut hash_slice = [0u8; 16];
    hash_slice.copy_from_slice(&digest.as_ref()[2..18]);

    let mut dec = [0u8; 8];
    for i in 0..8 {
        if i % 2 != 0 {
            if hash_slice[i * 2] != (block[i * 2]) {
                return Err(anyhow!("flag data broken"));
            }
        }
        dec[i] = hash_slice[i * 2 + 1] ^ block[i * 2 + 1];
    }

    let decrypted = crate::util::xxtea::decrypt_raw(&dec, key);
    let mut decrypted_slice = [0u8; 8];
    decrypted_slice.copy_from_slice(&decrypted);
    Ok(i64::from_le_bytes(decrypted_slice))
}

#[cfg(test)]
mod tests {
    const SEED: &str = "MyLittlePony";
    const KEY: &str = "Fr1endShip1sM4g1c";

    #[test]
    pub fn test() {
        let mut payloads: Vec<String> = Vec::new();

        for i in 2010..2021 {
            let suid = super::encode(SEED, i as i64, KEY, false);
            println!("{i} {:?}", suid);
            payloads.push(suid);
        }

        for payload in payloads {
            let payload = &payload;
            let data = super::decode(SEED, payload, KEY).unwrap();
            println!("{payload} {:?}", data)
        }
    }
}
