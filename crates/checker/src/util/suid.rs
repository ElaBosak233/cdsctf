//! Suid util for suid module.
//!
//! # What is `suid`
//! A fake uuid with steganography.
//!
//! Modified from https://github.com/ret2shell/ret2script.

use uuid::Uuid;

/// Encode seed to suid with data and key.
///
/// # Params
/// - `seed`: The origin flag. Such as `HelloWorld`.
/// - `data`: The data which is used to hide into leet flag. Usually operator's id.
/// - `key`: The key for encryption.
pub fn encode(seed: &str, data: i64, key: &str, hyphenated: bool) -> String {
    // Convert seed and key to byte arrays.
    let seed_bytes = seed.as_bytes();
    let key_bytes = key.as_bytes();

    // Use HMAC-SHA256 to compute pseudorandom data.
    let signing_key = ring::hmac::Key::new(ring::hmac::HMAC_SHA256, key_bytes);
    let tag = ring::hmac::sign(&signing_key, seed_bytes);
    let tag_bytes = tag.as_ref();
    // Take the first 16 bytes as pseudorandom data.
    let prng = &tag_bytes[0..16];

    // Split these 16 bytes into two parts: the first 8 bytes as random padding (upper part),
    // and the last 8 bytes for XOR with the data (lower part).
    let upper = &prng[0..8];
    let lower = &prng[8..16];

    // Convert the lower 8 bytes into an u64.
    let lower_val = u64::from_be_bytes(lower.try_into().unwrap());
    // XOR to get the "masked data".
    let obfuscated = data as u64 ^ lower_val;

    // Construct a 16-byte array: first 8 bytes from upper, last 8 bytes from obfuscated.
    let mut result = [0u8; 16];
    result[0..8].copy_from_slice(upper);
    result[8..16].copy_from_slice(&obfuscated.to_be_bytes());

    // Format as a UUID string using the uuid crate.
    let uuid = Uuid::from_bytes(result);

    if !hyphenated {
        return uuid.as_simple().to_string()
    }

    uuid.to_string()
}

/// Decode payload to data with seed and key.
///
/// # Params
/// - `seed`: The origin flag. Such as `HelloWorld`.
/// - `payload`: The suid flag which is generated by the `encode` function.
/// - `key`: The key for encryption.
pub fn decode(seed: &str, payload: &str, key: &str) -> Result<i64, anyhow::Error> {
    // Convert seed and key to byte arrays.
    let seed_bytes = seed.as_bytes();
    let key_bytes = key.as_bytes();

    // Parse the UUID string into a 16-byte array.
    let uuid = Uuid::parse_str(payload)?;
    let bytes = uuid.as_bytes();

    // Recompute HMAC to obtain the same 16 bytes of pseudorandom data.
    let signing_key = ring::hmac::Key::new(ring::hmac::HMAC_SHA256, key_bytes);
    let tag = ring::hmac::sign(&signing_key, seed_bytes);
    let tag_bytes = tag.as_ref();
    let prng = &tag_bytes[0..16];
    let lower = &prng[8..16];
    let lower_val = u64::from_be_bytes(lower.try_into()?);

    // Extract the obfuscated data from the last 8 bytes of the byte array.
    let obfuscated = u64::from_be_bytes(bytes[8..16].try_into()?);
    // XOR to recover the original data.
    let data = (obfuscated ^ lower_val) as i64;

    Ok(data)
}

#[cfg(test)]
mod tests {
    const SEED: &str = "MyLittlePony";
    const DATA: i64 = 2010;
    const KEY: &str = "Fr1endShip1sM4g1c";
    const PAYLOAD: &str = "3cab907f3eab185d671a4ba1c752b48b";

    #[test]
    pub fn encode_test() {
        let suid = super::encode(SEED, DATA, KEY, false);
        println!("{:?}", suid);

        assert_eq!(suid, PAYLOAD)
    }

    #[test]
    pub fn decode_test() {
        let data = super::decode(SEED, PAYLOAD, KEY).unwrap();
        println!("{:?}", data);

        assert_eq!(data, DATA)
    }
}