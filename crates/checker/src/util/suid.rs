//! Suid util for suid module.
//!
//! # What is `suid`
//! A fake uuid with steganography.
//!
//! Modified from https://github.com/ret2shell/ret2script.

use aes::cipher::{BlockDecrypt, BlockEncrypt, KeyInit};
use anyhow::anyhow;
use ring::{
    hkdf::{HKDF_SHA256, Salt},
    hmac,
    rand::{SecureRandom, SystemRandom},
};
use uuid::Uuid;

fn derive_keys_from_string(key: &str) -> ([u8; 16], [u8; 32]) {
    let salt = Salt::new(HKDF_SHA256, b"uuid");
    let prk = salt.extract(key.as_bytes());

    // Expand for the first time: Derive the AES key (32 bytes -> truncated 16)
    let okm_enc = prk
        .expand(&[b"suid-enc"], HKDF_SHA256)
        .expect("HKDF expand(enc) failed");

    let mut tmp_enc = [0u8; 32];
    okm_enc.fill(&mut tmp_enc).expect("HKDF fill(enc) failed");

    let mut k_enc = [0u8; 16];
    k_enc.copy_from_slice(&tmp_enc[..16]); // 128-bit AES key

    // Expand for the second time: Derive HMAC key (integer 32 bytes)
    let okm_mac = prk
        .expand(&[b"suid-mac"], HKDF_SHA256)
        .expect("HKDF expand(mac) failed");

    let mut k_mac = [0u8; 32];
    okm_mac.fill(&mut k_mac).expect("HKDF fill(mac) failed");

    (k_enc, k_mac)
}

/// Truncate HMAC-SHA256 -> 32 bits
fn hmac32(k_mac: &[u8; 32], msg: &[u8]) -> [u8; 4] {
    let key = hmac::Key::new(hmac::HMAC_SHA256, k_mac);
    let tag = hmac::sign(&key, msg);
    let tag_bytes = tag.as_ref();

    [tag_bytes[0], tag_bytes[1], tag_bytes[2], tag_bytes[3]]
}

/// Encode seed to suid with data and key.
///
/// # Params
/// - `data`: The data which is used to hide into leet flag. Usually operator's
///   id.
/// - `key`: The key for encryption.
pub fn encode(data: i64, key: &str, hyphenated: bool) -> String {
    let (k_enc, k_mac) = derive_keys_from_string(key);

    let m_bytes = data.to_be_bytes(); // signed OK

    // 4 byte random
    let rng = SystemRandom::new();
    let mut r_bytes = [0u8; 4];
    rng.fill(&mut r_bytes).unwrap();

    // MAC = HMAC(M || R)
    let mut buf = [0u8; 12];
    buf[..8].copy_from_slice(&m_bytes);
    buf[8..].copy_from_slice(&r_bytes);
    let t_bytes = hmac32(&k_mac, &buf);

    // P = M || T || R
    let mut plain = [0u8; 16];
    plain[..8].copy_from_slice(&m_bytes);
    plain[8..12].copy_from_slice(&t_bytes);
    plain[12..16].copy_from_slice(&r_bytes);

    // AES-128-ECB encrypt
    let cipher = aes::Aes128::new_from_slice(&k_enc).unwrap();
    let mut block = aes::Block::default();
    block.copy_from_slice(&plain);
    cipher.encrypt_block(&mut block);

    // hex UUID-like output
    let mut result = String::new();
    for i in 0..16 {
        result.push_str(&format!("{:02x}", block[i]));
        if hyphenated && (i == 3 || i == 5 || i == 7 || i == 9) {
            result.push('-');
        }
    }
    result
}

/// Decode payload to data with seed and key.
///
/// # Params
/// - `payload`: The suid flag which is generated by the `encode` function.
/// - `key`: The key for encryption.
pub fn decode(payload: &str, key: &str) -> Result<i64, anyhow::Error> {
    let raw_hex = Uuid::parse_str(payload)?.as_simple().to_string();
    let cipher_bytes = hex::decode(&raw_hex)?;

    if cipher_bytes.len() != 16 {
        return Err(anyhow!("Invalid suid length"));
    }

    let (k_enc, k_mac) = derive_keys_from_string(key);

    // AES-128-ECB decrypt
    let cipher = aes::Aes128::new_from_slice(&k_enc)?;
    let mut block = aes::Block::default();
    block.copy_from_slice(&cipher_bytes);
    cipher.decrypt_block(&mut block);

    let p = block;

    // split
    let mut m_bytes = [0u8; 8];
    let mut t_bytes = [0u8; 4];
    let mut r_bytes = [0u8; 4];

    m_bytes.copy_from_slice(&p[..8]);
    t_bytes.copy_from_slice(&p[8..12]);
    r_bytes.copy_from_slice(&p[12..16]);

    // verify MAC
    let mut buf = [0u8; 12];
    buf[..8].copy_from_slice(&m_bytes);
    buf[8..].copy_from_slice(&r_bytes);
    let expected = hmac32(&k_mac, &buf);

    if expected != t_bytes {
        return Err(anyhow!("MAC check failed"));
    }

    Ok(i64::from_be_bytes(m_bytes))
}

#[cfg(test)]
mod tests {
    const KEY: &str = "Fr1endShip1sM4g1c";

    #[test]
    pub fn test() {
        let mut payloads: Vec<String> = Vec::new();

        for i in 2010..2021 {
            let suid = super::encode(i as i64, KEY, false);
            println!("{i} {:?}", suid);
            payloads.push(suid);
        }

        for payload in payloads {
            let payload = &payload;
            let data = super::decode(payload, KEY).unwrap();
            println!("{payload} {:?}", data)
        }
    }
}
