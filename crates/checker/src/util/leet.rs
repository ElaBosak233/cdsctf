//! Leet util for leet module.
//!
//! Modified from https://github.com/ret2shell/ret2script.

use std::{collections::HashMap, io};

use once_cell::sync::Lazy;

pub static LEET_CHAR_TABLE: Lazy<HashMap<u8, Vec<u8>>> = Lazy::new(|| {
    HashMap::from([
        (b'0', vec![b'0', b'O']),
        (b'1', vec![b'1', b'l', b'I']),
        (b'2', vec![b'2', b'Z']),
        (b'3', vec![b'3']),
        (b'4', vec![b'4', b'A']),
        (b'5', vec![b'5', b'S']),
        (b'6', vec![b'6', b'b']),
        (b'7', vec![b'7']),
        (b'8', vec![b'8', b'B']),
        (b'9', vec![b'9']),
        (b'a', vec![b'a', b'A', b'@', b'4']),
        (b'b', vec![b'b', b'B', b'6']),
        (b'c', vec![b'c', b'C']),
        (b'd', vec![b'd', b'D']),
        (b'e', vec![b'e', b'E', b'3']),
        (b'f', vec![b'f', b'F']),
        (b'g', vec![b'g', b'G']),
        (b'h', vec![b'h', b'H']),
        (b'i', vec![b'i', b'I', b'1', b'l']),
        (b'j', vec![b'j', b'J']),
        (b'k', vec![b'k', b'K']),
        (b'l', vec![b'l', b'L', b'1', b'I']),
        (b'm', vec![b'm', b'M']),
        (b'n', vec![b'n', b'N']),
        (b'o', vec![b'o', b'O', b'0']),
        (b'p', vec![b'p', b'P']),
        (b'q', vec![b'q', b'Q']),
        (b'r', vec![b'r', b'R']),
        (b's', vec![b's', b'S', b'5']),
        (b't', vec![b't', b'T']),
        (b'u', vec![b'u', b'U']),
        (b'v', vec![b'v', b'V']),
        (b'w', vec![b'w', b'W']),
        (b'x', vec![b'x', b'X']),
        (b'y', vec![b'y', b'Y']),
        (b'z', vec![b'z', b'Z', b'2']),
        (b'A', vec![b'A', b'a', b'@', b'4']),
        (b'B', vec![b'B', b'b', b'8']),
        (b'C', vec![b'C', b'c']),
        (b'D', vec![b'D', b'd']),
        (b'E', vec![b'E', b'e', b'3']),
        (b'F', vec![b'F', b'f']),
        (b'G', vec![b'G', b'g']),
        (b'H', vec![b'H', b'h']),
        (b'I', vec![b'I', b'i', b'1', b'l']),
        (b'J', vec![b'J', b'j']),
        (b'K', vec![b'K', b'k']),
        (b'L', vec![b'L', b'l', b'1', b'I']),
        (b'M', vec![b'M', b'm']),
        (b'N', vec![b'N', b'n']),
        (b'O', vec![b'O', b'o', b'0']),
        (b'P', vec![b'P', b'p']),
        (b'Q', vec![b'Q', b'q']),
        (b'R', vec![b'R', b'r']),
        (b'S', vec![b'S', b's', b'5']),
        (b'T', vec![b'T', b't']),
        (b'U', vec![b'U', b'u']),
        (b'V', vec![b'V', b'v']),
        (b'W', vec![b'W', b'w']),
        (b'X', vec![b'X', b'x']),
        (b'Y', vec![b'Y', b'y']),
        (b'Z', vec![b'Z', b'z', b'2']),
        (b'_', vec![b'_', b'-']),
        (b'-', vec![b'-', b'_']),
        (b'!', vec![b'!', b'1', b'l']),
    ])
});

/// Encode template to leet flag with data and key.
///
/// # Params
/// - `template`: The origin flag. Such as `HelloWorld`.
/// - `data`: The data which is used to hide into leet flag. Usually operator's id.
/// - `key`: The key for encryption.
pub fn encode(template: &str, data: i64, key: &str) -> String {
    let encrypted = super::xxtea::encrypt_raw(&data.to_le_bytes(), key);
    // turn the encrypted data into an i64
    let mut encrypted_slice = [0; 8];
    encrypted_slice.copy_from_slice(&encrypted);
    let mut e = u64::from_le_bytes(encrypted_slice);
    // println!("e: {e}");
    let mut result = String::new();
    for c in template.chars() {
        if let Some(replace) = LEET_CHAR_TABLE.get(&(c as u8)) {
            let modular = e % replace.len() as u64;
            let ec = replace[modular as usize] as char;
            result.push(ec);
            e /= replace.len() as u64;
        } else {
            result.push(c);
        }
    }
    result.push_str(&format!("{:x}", e));

    result
}

/// Decode payload to data with template and key.
///
/// # Params
/// - `template`: The origin flag. Such as `HelloWorld`.
/// - `payload`: The leet flag which is generated by `encode` function.
/// - `key`: The key for encryption.
pub fn decode(template: &str, payload: &str, key: &str) -> Result<i64, io::Error> {
    // split the data into encrypted data and hex string using template's length
    let template_len = template.len();
    if template_len >= payload.len() {
        return Err(io::Error::other("flag length mis-patch"));
    }
    let (e_data, e_hex) = payload
        .split_at_checked(template_len)
        .ok_or(io::Error::other("flag length mis-patch"))?;
    let mut e_data = e_data.chars().rev();
    let mut e = u64::from_str_radix(e_hex, 16).map_err(|_| io::Error::other("flag data broken"))?;
    for c in template.chars().rev() {
        let ec = e_data
            .next()
            .ok_or(io::Error::other("flag length mis-patch"))?;
        if let Some(replace) = LEET_CHAR_TABLE.get(&(c as u8)) {
            // println!("c: {c}, replace: {replace:?}, e: {e}, ec: {ec}");
            let char_t_index = replace
                .iter()
                .position(|&x| x == ec as u8)
                .ok_or(io::Error::other("flag data broken"))?;
            // println!("e: {e}, c: {c}, ec: {ec}, e_index: {char_t_index}");
            e = e
                .checked_mul(replace.len() as u64)
                .ok_or(io::Error::other("flag data broken"))?
                .checked_add(char_t_index as u64)
                .ok_or(io::Error::other("flag data broken"))?;
        }
    }
    // println!("e: {e}");
    let decrypted = super::xxtea::decrypt_raw(&e.to_le_bytes(), key);
    let mut decrypted_slice = [0; 8];
    decrypted_slice.copy_from_slice(&decrypted);

    Ok(i64::from_le_bytes(decrypted_slice))
}

#[cfg(test)]
mod tests {
    const TEMPLATE: &str = "MyLittlePony";
    const DATA: i64 = 2010;
    const KEY: &str = "Fr1endShip1sM4g1c";
    const PAYLOAD: &str = "my11ttL3p0ny4c75b159b440";

    #[test]
    pub fn encode_test() {
        assert_eq!(super::encode(TEMPLATE, DATA, KEY), PAYLOAD)
    }

    #[test]
    pub fn decode_test() {
        assert_eq!(super::decode(TEMPLATE, PAYLOAD, KEY).unwrap(), DATA)
    }
}